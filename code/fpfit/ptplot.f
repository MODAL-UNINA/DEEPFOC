      PROGRAM PTPLOT
C
C     PURPOSE:       PLOT "P" AND  "T" AXES FOR A SUITE OF EARTHQUAKE FOCAL MECHANISMS ON A LOWER HEMISPHERE EQUAL AREA PROJECTION.
C                    AND ASSOCIATED 95% CONFIDENCE REGIONS FROM BINGHAM DISTRIBUTION
C
C     INPUT FILE:    A FILE OF THE TYPE "*.FPS", WHICH IS GENERATED BY THE PROGRAM "FPFIT" (SEE "FPFIT: A COMPUTER PROGRAM FOR 
C                    OBTAINING DOUBLE-COUPLE FAULT-PLANE SOLUTIONS FROM FIRST-MOTION POLATITY OBSERVATIONS OF AN EARTHQUAKE", 
C                    BY P. REASENBERG AND D. OPPENHEIMER, BOTH AT U.S. GEOLOGICAL SURVEY, MENLO PARK, CALIFORNIA).
C
C     REQUIRED ROUTINES: CALCOMP STYLE PLOT ROUTINES PLOTS, PLOT, NEWPEN, SYMBOL.
C
C     DEPARTURES FROM FORTRAN-77 STANDARD:
C              1. KEYWORD "READONLY" IN OPEN STATEMENT (MAIN)
C              2. ARGUMENT LIST BUILT-IN FUNCTION "%REF" 
C              3. CALLS TO VAX SYSTEM ROUTINES "SYS$BINTIM", "SYS$SCHDWK", "SYS$HIBER"  (SUBROUTINE DELAY)
C
C      OUTPUT:       GRAPHIC AND OPTIONAL ASCII OUTPUT 
C
C      AUTHORS: DAVID OPPENHEIMER.  THIS PROGRAM WAS PULLED TOGETHER FROM MANY SEPARATE ROUTINES AT THE U.S.G.S. IN MENLO PARK.  
C               MANY OF THE ROUTINES WERE EXTRACTED FROM CODE WRITTEN BY PAUL REASENBERG, JOHN LAHR, BRUCE JULIAN, AND FRED KLEIN.  
C               BINGHAM STATISTICS ROUTINES ARE FROM JOE KIRSCHVINK (CALTECH) VIA SHERMAN GROMME (USGS).
C
      INTEGER           MXFPS                           ! MAXIMUM # OF SOLUTIONS
C
      PARAMETER (MXFPS = 5000)
C
      REAL              AIN1                            ! ANGLE OF INCIDENCE P AXIS
      REAL              AIN2                            ! ANGLE OF INCIDENCE T AXIS
      CHARACTER*1       ANS                             ! INTERACTIVE RESPONSE
      REAL              AZ1                             ! AZIMUTH OF P AXIS
      REAL              AZ2                             ! AZIMUTH OF T AXIS
      REAL              A9512                           ! CONFIDENCE ANGLE ABOUT 1-AXIS IN 2 DIRECTION
      REAL              A9513                           ! CONFIDENCE ANGLE ABOUT 1-AXIS IN 3 DIRECTION
      REAL              A9523                           ! CONFIDENCE ANGLE ABOUT 2-AXIS IN 3 DIRECTION
      REAL              CX1                             ! X POSITION OF FIRST STEREO NET CENTER
      REAL              CX2                             ! X POSITION OF SECOND STEREO NET CENTER
      REAL              CY                              ! Y POSITION OF STEREO NET CENTER
      REAL              DA1                             ! DIP ANGLE OF PRINCIPAL PLANE
      REAL              DA2                             ! DIP ANGLE OF AUXILLIARY/PRINCIPAL PLANE
      REAL              DD1                             ! DIP DIRECTION OF PRINCIPAL PLANE
      REAL              DD2                             ! DIP DIRECTION OF AUXILLIARY/PRINCIPAL PLANE
      REAL              EIGNV(9)                        ! EIGENVECTORS
      CHARACTER*50      FILNAM                          ! FILE NAME 
      REAL              HITE                            ! HEIGHT OF P,T SYMBOL IN LARGE CIRCLE
      INTEGER           I                               ! LOOP INDEX 
      INTEGER           INDEX1                          ! INDEX TO FIRST CHARACTER IN FILNAM AFTER RIGHT BRACKET (])
      INTEGER           INDEX2                          ! INDEX TO PERIOD (.) IN FILNAM 
      INTEGER           IPAXIS                          ! FLAG: INDICATES WHICH PRINCIPAL AXIS IS PLOTTED FOR P AXES
      INTEGER           ITAXIS                          ! FLAG: INDICATES WHICH PRINCIPAL AXIS IS PLOTTED FOR T AXES
      INTEGER           IUNIT                           ! LOGICAL UNIT # OF INPUT FILE
      INTEGER           JASK                            ! FUNCTION
      CHARACTER*50      LINE                            ! SCRATCH LINE
      INTEGER           NP                              ! NUMBER OF P,T AXES
      INTEGER           OUNIT                           ! LOGICAL UNIT # OF OUTPUT FILE
      REAL              PDEC(MXFPS)                     ! P AXIS DECLINATION
      REAL              PI                              ! PI
      REAL              PPLNG(MXFPS)                    ! P AXIS PLUNGE
      REAL              RAD                             ! PI/180
      REAL              RMAX                            ! RADIUS OF STEREO NET CIRCLE
      REAL              SA1                             ! RAKE OF PRINCIPAL PLANE
      REAL              SA2                             ! RAKE OF AUXILLIARY/PRINCIPAL PLANE
      REAL              SK1                             ! BINGHAM CONCENTRATION PARAMETER
      REAL              SK2                             ! BINGHAM CONCENTRATION PARAMETER
      REAL              SP(9)                           ! SYMETRIC MATRIX CONTAINING (ULTIMATELY) EIGEN VALUES 
      REAL              SSD1                            ! ANGULAR STANDARD DEVIATION OF DATA (NOT USED)
      REAL              SSD2                            ! ANGULAR STANDARD DEVIATION OF DATA (NOT USED)
      REAL              SSD3                            ! ANGULAR STANDARD DEVIATION OF DATA (NOT USED)
      REAL              TDEC(MXFPS)                     ! T AXIS DECLINATION
      CHARACTER*50      TITLE                           ! FILE NAME 
      REAL              TMP                             ! SCRATCH VARIABLE
      REAL              TPLNG(MXFPS)                    ! T AXIS PLUNGE
      LOGICAL           Y2K				! T(F) = .POL FILE FORMAT IS (NOT) Y2K COMPATIBLE
C
C      PARAMETER (CX1 = 3.0, CX2 = 10.0, CY = 3.0, HITE = 0.2, RMAX = 
C    &2.95, IUNIT = 12, OUNIT = 13)
      PARAMETER (CX1 = 1.5, CX2 = 5.0, CY = 1.5, HITE = 0.1, RMAX = 
     &1.50, IUNIT = 12, OUNIT = 13)
      PI = ATAN(1.0)*4.0
      RAD = PI/180.0
      NP = 0
C
10    FILNAM = 'NONE'
      CALL ASKC ('ENTER NAME OF ".FPS" FILE:  ', FILNAM)
      IF (FILNAM .NE. 'NONE') THEN
        OPEN (IUNIT, FILE = FILNAM, STATUS = 'OLD', BLANK
     & = 'ZERO', IOSTAT = IOS)
      END IF
      IF (IOS .NE. 0 .OR. FILNAM .EQ. 'NONE') THEN
        PRINT *, ' ERROR OPENING FILE - TRY AGAIN'
        GOTO 10
      ELSE
c
c  is this y1k or y2k format?
c
        read (iunit, '(a)') line
        read (iunit, '(a)') line
        if (line(15:15) .eq. '.' .and. line(34:34) .eq. '.') then
          y2k = .false.
        elseif (line(17:17) .eq. '.' .and. line(36:36) .eq. '.') then
          y2k = .true.
        else
          write (*, '(a)')
     1 'Unable to determine whether file is y1k or y2k format'
          stop
        end if
        rewind (iunit)
      end if
      INQUIRE (IUNIT, NAME = FILNAM)
c      CALL DATE(DATSTR)
c      TITLE = FILNAM//' '//DATSTR
      TITLE = FILNAM
30    ANS = 'y'
      CALL ASKC ('CALCULATE ROTATIONAL AXES OF SYMMETRY (Y OR N)?  ',
     & ANS)
      IF (ANS .NE. 'y' .AND. ANS .NE. 'n') THEN
        PRINT *, '***** PLEASE ANSWER "y" OR "n"; TRY AGAIN *****'
        GOTO 30
      END IF
      IF (ANS .EQ. 'y') THEN
40      IPAXIS = 4
        IPAXIS = JASK ('ABOUT WHICH PRINCIPAL P AXIS (1, 2, 3, OR 4=ALL)
     &?  ', IPAXIS)
        IF (IPAXIS .LT. 1 .OR. IPAXIS .GT. 4) THEN
          PRINT *, '***** INVALID RESPONSE; TRY AGAIN *****'
          GOTO 40
        END IF
50      ITAXIS = 4
        ITAXIS = JASK ('ABOUT WHICH PRINCIPAL T AXIS (1, 2, 3, OR 4=ALL)
     &?  ', ITAXIS)
        IF (ITAXIS .LT. 1 .OR. ITAXIS .GT. 4) THEN
          PRINT *, '***** INVALID RESPONSE; TRY AGAIN *****'
          GOTO 50
        END IF
c        INDEX1 = INDEX(FILNAM, ']') + 1
c        INDEX2 = INDEX(FILNAM, ';')
        INDEX1 = 1
        INDEX2 = leng(filnam)
        DO 51 I = INDEX2, INDEX1, -1
          IF (FILNAM(I:I) .EQ. '.') GOTO 52
51      CONTINUE
        PRINT *, 'ERROR DECODING FILNAM'
        STOP
52      INDEX2 = I
        FILNAM = FILNAM(INDEX1:INDEX2)//'AXES'
	WRITE (6, 55) FILNAM
55      FORMAT (/, 1X, 
     1 'ORIENTATION AND CONFIDENCE ANGLES OF AXES WILL BE WRITTEN TO ',
     2  A)
        OPEN (UNIT = OUNIT, FILE = FILNAM, STATUS = 'unknown')
      ELSE IF (ANS .EQ. 'n') THEN
        IPAXIS = 0
        ITAXIS = 0
      ELSE
        PRINT *, '***** PLEASE ANSWER "y" OR "n" *****'
        GOTO 30
      END IF
C
C INITIALIZE PLOT PROGRAM
C
      CALL PLOTS (0., 0., 0)
C
C START NEW FRAME
C
C      CALL ERASE
C      CALL DELAY ('0000 00:00:01.00')
      CALL PLOT (0.5, 1.0, -3)
      CALL NEWPEN (2)
C
C PLOT STEREO NET PERIMETERS
C
      CALL STRNET (CX1, CY, RAD, RMAX)
      CALL SYMBL (CX1 - 6.*HITE/2., CY*2. + .5, HITE, 'P AXES', 0., 6)
      CALL STRNET (CX2, CY, RAD, RMAX)
      CALL SYMBL (CX2 - 6.*HITE/2., CY*2. + .5, HITE, 'T AXES', 0., 6)
      CALL SYMBL (CX1 + (CX2 - CX1)/2. - 25.*HITE/2., CY*2. + 1., HITE,
     & TITLE, 0., 50)

C READ EXTENDED SUMMARY CARD
C
60    if (.not. y2k) then
	READ (IUNIT, 70, END = 1000) DD1, DA1, SA1
70      FORMAT (T81, F4.0, F3.0, F4.0)
      else
	READ (IUNIT, 71, END = 1000) DD1, DA1, SA1
71      FORMAT (T83, F4.0, F3.0, F4.0)
      endif
C
C FIND AUXILLIARY PLANE
C
        CALL AUXPLN (DD1, DA1, SA1, DD2, DA2, SA2)
C
C FIND P AND T AXES
C
        CALL TANDP (AIN1, AIN2, AZ1, AZ2, DA1, DA2, DD1, DD2, SA1, SA2,
     1 PI, RAD)
C
C  MAKE P-AXIS "1"
C
        IF (SA1 .GE. 0.) THEN
          TMP = AIN1
          AIN1 = AIN2
          AIN2 = TMP
          TMP = AZ1
          AZ1 = AZ2
          AZ2 = TMP
        END IF
C
C  MAP AXES TO LOWER HEMISPHERE 
C
        IF (AIN1 .GT. 90.) THEN
          AIN1 = 180. - AIN1
          AZ1 = 180. + AZ1
        END IF
        IF (AIN2 .GT. 90.) THEN
          AIN2 = 180. - AIN2
          AZ2 = 180. + AZ2
        END IF
        IF (AZ1 .LT. 0.) AZ1 = AZ1 + 360.
        IF (AZ2 .LT. 0.) AZ2 = AZ2 + 360.
C
C  PLOT POINT AND ACCUMULATE VECTORS FOR BINGHAM STATISTICS
C
C        CALL PLTSYM (AIN1, AZ1, CX1, CY, HITE/2., '    ', PI, RAD, RMAX,
C     & '+', 1.0)
C        CALL PLTSYM (AIN2, AZ2, CX2, CY, HITE/2., '    ', PI, RAD, RMAX,
C     & '+', 1.0)
       CALL PLTSYP (AIN1, AZ1, CX1, CY, HITE/4., '    ', PI, RAD, RMAX,
     & 'C', 1.0)
       CALL PLTSYP (AIN2, AZ2, CX2, CY, HITE/4., '    ', PI, RAD, RMAX,
     & 'C', 1.0)
        IF (IPAXIS .NE. 0.) THEN
          NP = NP + 1
          IF (NP .GT. MXFPS) THEN
            PRINT *, 'NUMBER OF SOLUTIONS CANNOT BE GREATER THAN', MXFPS
            STOP
          END IF
          PDEC(NP) = AZ1
          PPLNG(NP) = 90. - AIN1
          TDEC(NP) = AZ2
          TPLNG(NP) = 90. - AIN2
        END IF
      GOTO 60
C
C END OF FILE
C
1000  IF (IPAXIS .NE. 0.) THEN
C
C COMPUTE BINGHAM STATISTICS ON P AXES
C
C FIRST FORM MATRIX
C
        CALL SUMPRD (PDEC, PPLNG, NP, SP)
C
C FIND EIGENVALUES, VECTORS
C
        CALL EIGEN (SP, EIGNV, 3, 0)
C
C COMPUTE CONCENTRATION PARAMETERS
C
        CALL FASTBING (SP(1), SP(3), SP(6), SK1, SK2)
C
C  COMPUTE 95% CONFIDENCE ANGLES ABOUT AXES
C
        CALL ANGLES(SK1, SK2, SP, SSD3, SSD2, SSD1, A9523, A9513, A9512)
        WRITE (OUNIT, 1010) (SP(I), I = 1, 3), SK1, SK2
1010    FORMAT (' P-AXES SUMMARY', /, ' --------------', /
     & ' EIGENVALUES = ', 3(E13.6, 3X), /,
     & ' BINGHAM CONCENTRATION PARAMETERS = ', 2(E13.6, 3X))
        WRITE (OUNIT, 1020) 1, 2, A9512
        WRITE (OUNIT, 1020) 1, 3, A9513
        WRITE (OUNIT, 1020) 2, 3, A9523
1020    FORMAT (' ALPHA 95 ANGLE BETWEEN ', I1, ', ', I1, ' AXES = ',
     & F5.1, ' DEG')
C
C PLOT PRINCIPAL AXES
C
        IF (IPAXIS .EQ. 1 .OR. IPAXIS .EQ. 4)  CALL PLTBNG (CX1, CY,
     & HITE, PI, RAD, RMAX, '1', A9512, A9513, EIGNV(1), EIGNV(4),
     & EIGNV(7), OUNIT)
        IF (IPAXIS .EQ. 2 .OR. IPAXIS .EQ. 4)  CALL PLTBNG (CX1, CY,
     & HITE, PI, RAD, RMAX, '2', A9523, A9512, EIGNV(4), EIGNV(7),
     & EIGNV(1), OUNIT)
        IF (IPAXIS .EQ. 3 .OR. IPAXIS .EQ. 4)  CALL PLTBNG (CX1, CY,
     & HITE, PI, RAD, RMAX, '3', A9513, A9523, EIGNV(7), EIGNV(1),
     & EIGNV(4), OUNIT)
C
C COMPUTE BINGHAM STATISTICS ON T AXES
C
        CALL SUMPRD (TDEC, TPLNG, NP, SP)
        CALL EIGEN (SP, EIGNV, 3, 0)
        CALL FASTBING (SP(1), SP(3), SP(6), SK1, SK2)
        CALL ANGLES(SK1, SK2, SP, SSD3, SSD2, SSD1, A9523, A9513, A9512)
        WRITE (OUNIT, 1030) (SP(I), I = 1, 3), SK1, SK2
1030    FORMAT (/, ' T-AXES SUMMARY', /, ' --------------', /
     & ' EIGENVALUES = ', 3(E13.6, 3X), /,
     & ' BINGHAM CONCENTRATION PARAMETERS = ', 2(E13.6, 3X))
        WRITE (OUNIT, 1020) 1, 2, A9512
        WRITE (OUNIT, 1020) 1, 3, A9513
        WRITE (OUNIT, 1020) 2, 3, A9523
        IF (ITAXIS .EQ. 1 .OR. ITAXIS .EQ. 4)  CALL PLTBNG (CX2, CY,
     1 HITE, PI, RAD, RMAX, '1', A9512, A9513, EIGNV(1), EIGNV(4),
     2 EIGNV(7), OUNIT)
        IF (ITAXIS .EQ. 2 .OR. ITAXIS .EQ. 4)  CALL PLTBNG (CX2, CY,
     1 HITE, PI, RAD, RMAX, '2', A9523, A9512, EIGNV(4), EIGNV(7),
     2 EIGNV(1), OUNIT)
        IF (ITAXIS .EQ. 3 .OR. ITAXIS .EQ. 4)  CALL PLTBNG (CX2, CY,
     1 HITE, PI, RAD, RMAX, '3', A9513, A9523, EIGNV(7), EIGNV(1),
     2 EIGNV(4), OUNIT)
      END IF
C      CALL PLOT (0., 0., 999)
      CALL PLOT (0., 0., -999)
      CLOSE (IUNIT)
      IF (IPAXIS .NE. 0) CLOSE (OUNIT)
      STOP
      END
c     subroutine ANGLES
c          j.l. kirschvink
c
c     purpose
c         compute the error angles around the eigenvectors, both
c         the one-sigma and 95% confidence. (after Bingham, 1974)
c
c     description of parameters
c         k1,k2 - Bingham concentration parameters (real numbers).
c         e - six element matrix returned by eigen containing the three
c         eigenvalues diagonally in descending order.
c         s12,s13,s23 - roughly, angular standard deviations of data.
c            (Note that these are not Bingham's sigmas.)
c         a12,a13,a23 - Bingham's 95% confidence angles.
c
c     Code for s123 changed by S.Gromme  Feb. 1987
c     Code for a123 corrected by S.Gromme  Feb. 1987; note that Onstott's
c      eigenvalues are normalized way back in the T matrix, whereas
c      Kirschvink did not do this (see subroutine SUMPRD).
c
       subroutine angles(k1,k2,e,s12,s13,s23,a12,a13,a23)
       dimension e(6)
       real k1,k2
       data deg/57.29578/
c     e(6),e(3), and e(1) are the eigenvalues from eigen
c       (not normalized)
       w1 = e(6)
       w2 = e(3)
       w3 = e(1)
c  normalizing factor, which is N for unit data
       rn = w1+w2+w3
c  estimate the angular standard deviations of the data
c    note that k1 < k2 < k3 = 0, and that here we do the
c    normalizations to eliminate dependency on N
       d12 = abs((k1-k2)*(w1-w2)/rn)
       d13 = abs(k1*(w1-w3)/rn)
       d23 = abs(k2*(w2-w3)/rn)
       s12 = deg/sqrt(2.*d12)
       s13 = deg/sqrt(2.*d13)
       s23 = deg/sqrt(2.*d23)
c  find bingham's 95% confidence angles around the eigenvector
c    using CHI SQ (0.05)(2) = 5.991
c    here we reintroduce the dependency on N
       chisq2 = 2.44765 / sqrt(rn)
       a12 = chisq2 * s12
       a13 = chisq2 * s13
       a23 = chisq2 * s23
       return
       end
      subroutine eigen ( a, r, n, mv )
c          Standard IBM Scientific Subroutine Package program.
c     Compute eigenvalues and eigenvectors of a real symmetric matrix.
c     a - n(n+1)/2  original symmetric matrix, upper triangle only.
c         destroyed in computation, eigenvalues developed in 'diagonal'.
c     r - (n*n)  resultant matrix of eigenvectors (stored columnwise)
c Input parameters:
c     n - order of matrices a and r.
c     mv- 0 = compute eigenvalues and eigenvectors.
c         1 = compute eigenvalues only.  (r need not be dimensioned)
c     Jacobi method, copied from IBM scien. support pack. pages 164-165.
c     Copied by Joe Kirschvink.  Sent to VMS March 1983 by SGromme.
c The input matrix to eigen looks like:
c   | a(1) a(2) a(4) |
c   |      a(3) a(5) |
c   |           a(6) |
c Eigenvalues are returned in a:
c   | a(1)longest                 |
c   |        a(3)intermediate     |
c   |                a(6)shortest |
c Eigenvectors are returned in r:
c   longest  intermediate  shortest
c   | r(1)      r(4)         r(7) |                  |x|
c   | r(2)      r(5)         r(8) | corresponding to |y| components.
c   | r(3)      r(6)         r(9) |                  |z|
c     For double precision, change sqrt in #40,68,75,78 to dsqrt, change
c     abs in #62 to dabs, change constant in #5 to 1.d-12, and add:
c     real*8 a,r,anorm,anrmx,thr,x,y,sinx,sinx2,cosx,cosx2,sincs,range
      dimension a(1), r(1)
c        generate identity matrix
    5 range = 1.e-6
      if (mv-1)  10, 25, 10
   10 iq = -n
      do 20 j=1,n
      iq = iq + n
      do 20 i=1,n
      ij = iq + i
      r(ij) = 0.
      if (i-j)  20, 15, 20
   15 r(ij) = 1.
   20 continue
c        compute initial and final norms (anorm and anormx)
   25 anorm = 0.
      do 35 i=1,n
      do 35 j=i,n
      if (i-j)  30, 35, 30
   30 ia = i + (j*j-j) / 2
      anorm = anorm + a(ia)*a(ia)
   35 continue
      if (anorm)  165, 165, 40
   40 anorm = 1.414 * sqrt(anorm)
      anrmx = anorm * range / float(n)
c        initialize indicators and compute threshold,  thr.
      ind = 0
      thr = anorm
   45 thr = thr / float(n)
   50 l = 1
   55 m = l + 1
c        compute sin and cos
   60 mq = (m*m-m) / 2
      lq = (l*l-l) / 2
      lm = l + mq
   62 if (abs(a(lm))-thr)  130, 65, 65
   65 ind = 1
      ll = l + lq
      mm = m + mq
      x = .5 * (a(ll)-a(mm))
   68 y = -a(lm) / sqrt(a(lm)*a(lm)+x*x)
      if (x)  70, 75, 75
   70 y = -y
   75 sinx = y / sqrt( 2.*(1.+sqrt(1.-y*y)) )
      sinx2 = sinx*sinx
   78 cosx = sqrt(1.-sinx2)
      cosx2 = cosx*cosx
      sincs = sinx*cosx
c        rotate l and m columns
      ilq = n*(l-1)
      imq = n * (m-1)
      do 125 i=1,n
      iq = (i*i-i) / 2
      if (i-l)  80, 115, 80
   80 if (i-m)  85, 115, 90
   85 im = i + mq
      go to 95
   90 im = m + iq
   95 if (i-l)  100, 105, 105
  100 il = i + lq
      go to 110
  105 il = l + iq
  110 x = a(il) * cosx  -  a(im) * sinx
      a(im) = a(il) * sinx  +  a(im) * cosx
      a(il) = x
  115 if (mv-1)  120, 125, 120
  120 ilr = ilq + i
      imr = imq + i
      x = r(ilr) * cosx  -  r(imr) * sinx
      r(imr) = r(ilr) * sinx  +  r(imr) * cosx
      r(ilr) = x
  125 continue
      x = 2. * a(lm) * sincs
      y = a(ll) * cosx2  +  a(mm) * sinx2  -  x
      x = a(ll) * sinx2  +  a(mm) * cosx2  +  x
      a(lm) = (a(ll)-a(mm)) * sincs  +  a(lm) * (cosx2-sinx2)
      a(ll) = y
      a(mm) = x
c        tests for completion.
c          test for m = last column.
  130 if (m-n)  135, 140, 135
  135 m = m + 1
      go to 60
c          test for l = second from last column
  140 if (l-n+1)  145, 150, 145
  145 l = l + 1
      go to 55
  150 if (ind-1)  160, 155, 160
  155 ind = 0
      go to 50
c        compare threshold with final norm
  160 if (thr-anrmx)  165, 165, 45
c        sort eigenvalues and eigenvectors
  165 iq = -n
      do 185 i=1,n
      iq = iq + n
      ll = i + (i*i-i) / 2
      jq = n * (i-2)
      do 185 j=i,n
      jq = jq + n
      mm = j + (j*j-j) / 2
      if (a(ll)-a(mm))  170, 185, 185
  170 x = a(ll)
      a(ll) = a(mm)
      a(mm) = x
      if (mv-1)  175, 185, 175
  175 do 180 k=1,n
      ilr = iq + k
      imr = jq + k
      x = r(ilr)
      r(ilr) = r(imr)
  180 r(imr) = x
  185 continue
      return
      end
      SUBROUTINE FASTBING(E3,E2,E1,BK1,BK2)
C
C THIS ROUTINE USES THE TABLE OF MAXIMUM LIKLIHOOD ESTIMATES
C FOR THE BINGHAM DISTRIBUTION (MARDIA & ZEMROCH, J. STATIST.
C COMPUT. SCI., 6, 29-34, 1977) TO ARRIVE AT A CLOSE GUESS FOR
C THE BINGHAM CONCENTRATION PARAMETERS K1 AND K2
C
C INPUT ARGUMENTS ARE THE EIGENVALUES E3, E2, E1,
C  WHERE  E3 > E2 > E1
C RETURNED ARGUMENTS ARE BK1, BK2
C
C From S. Gillett via J. Kirschvink; transcribed J. Hagstrum.
C (That version did not work.)
C Interpolation algorithm recoded S. Gromme, Jan. 1987.
C  Linear interpolation is used if abs(k(i))<3, and harmonic
C   interpolation is used otherwise.
C 
C ARRAYS IK1 AND IK2 ARE THE TABLES GIVEN IN THE REFERENCE, BUT
C  MULTIPLIED BY 1000 AND STORED AS INTEGERS.  THE PADDING IS
C  CHANGED FROM 0.0 TO O.OO1 TO AVOID DIVIDE CHECKS.
C THE INCREMENTS OF T1 AND T2 ARE 0.02.
C
      LOGICAL HARM1,HARM2
      DIMENSION IK1(16,24), IK2(16,24)
C
      DATA IK1 /25550,15*1,25560,13110,14*1,25580,13140,9043,13*1,25600,
     &13160,9065,7035,12*1,25620,13180,9080,7042,5797,11*1,25630,13190,
     &9087,7041,5789,4917,10*1,25640,13200,9087,7033,5773,4896,4231,9*1,
     &25650,13200,9081,7019,5752,4868,4198,3659,8*1,25650,13190,9068,
     &6999,5726,4836,4160,3616,3160,7*1,25640,13180,9050,6974,5694,4799,
     &4118,3570,3109,2709,6*1,25630,13170,9027,6944,5658,4757,4071,3518,
     &3053,2649,2889,5*1,25610,13140,8999,6910,5618,4711,4021,3463,2993,
     &2584,2220,1888,4*1,25590,13120,8966,6870,5573,4661,3965,3403,2928,
     &2515,2146,1809,1497,3*1,25570,13090,8928,6827,5523,4606,3906,3338,
     &2859,2441,2066,1724,1406,1106,2*1,25540,13050,8886,6778,5469,4547,
     &3842,3269,2785,2361,1981,1634,1309,1002,708,0,25500,13010,8839,
     &6725,5411,4484,3773,3195,2706,2277,1891,1537,1206,891,588,292,
     &25460,12960,8788,6668,5348,4415,3699,3116,2621,2186,1794,1433,
     &1094,771,459,152,25420,12910,8731,6606,5280,4342,3620,3032,2531,
     &2089,1690,1322,974,642,2*1,25370,12860,8670,6539,5207,4263,3536,
     &2941,2434,1986,1579,1202,4*1,25310,12800,8604,6466,5129,4179,3446,
     &2845,2330,1874,6*1,25250,12730,8532,6388,5045,4089,3349,2741,8*1,
     &25190,12660,8454,6305,4955,3992,10*1,25120,12580,8371,6215,12*1,
     &25040,12500,14*1/
C
      DATA IK2 /25550,15*1,13090,13110,14*1,8996,9019,9043,13*1,6977,
     &6999,7020,7035,12*1,5760,5777,5791,5798,5797,11*1,4923,4934,4941,
     &4941,4933,4917,10*1,4295,4301,4301,4294,4279,4258,4231,9*1,3796,
     &3796,3790,3777,3756,3729,3697,3659,8*1,3381,3375,3363,3345,3319,
     &3287,3249,3207,3160,7*1,3025,3014,2997,2973,2942,2905,2863,2816,
     &2765,2709,6*1,2712,2695,2673,2644,2609,2568,2521,2470,2414,2354,
     &2289,5*1,2431,2410,2382,2349,2309,2263,2212,2157,2097,2032,1963,
     &1888,4*1,2175,2149,2117,2078,2034,1984,1929,1869,1805,1735,1661,
     &1582,1497,3*1,1939,1908,1871,1828,1779,1725,1665,1601,1532,1458,
     &1378,1294,1203,1106,2*1,1718,1682,1641,1593,1540,1481,1417,1348,
     &1274,1195,1110,1020,923,819,708,0,1510,1470,1423,1371,1313,1250,
     &1181,1108,1028,944,853,756,653,541,421,292,1312,1267,1216,1159,
     &1096,1028,955,876,791,701,604,500,389,269,140,0,1123,1073,1017,
     &955,887,814,736,651,561,464,360,249,129,1,2*1,940,885,824,757,684,
     &606,522,432,335,231,120,1,4*1,762,702,636,564,486,402,312,215,111,
     &1,6*1,589,523,452,374,290,200,104,1,8*1,418,347,270,186,97,1,10*1,
     &250,173,90,1,12*1,83,1,14*1/
C
      DATA TH/-1000./
C
C INITIALIZE THE CHOICES
C
      HARM1 = .FALSE.
      HARM2 = .FALSE.
C
C NORMALIZE THE EIGENVALUES
C
      F = E1 + E2 + E3
      T1 = E1/F
      T2 = E2/F
C
C GO TO THE MARDIA APPROXIMATION IF T1 OR T2 < .02
C
      IF((T1.LT..02).OR.(T2.LT..02)) GO TO 50
C
C MAKE THE TABLE INDICES FROM T1 AND T2
C  WE WANT FOUR VALUES FROM EACH TABLE, BRACKETING T1 AND T2
C  I POINTS IN T1 DIRECTION,  J POINTS IN T2 DIRECTION
C
      TI = 100.*T1/2.
      IL = INT(TI)
      IF (IL.GT.15) IL = 15
      IH = IL+1
C
      TJ = 100.*T2/2.
      JL = INT(TJ)
      IF (JL.GT.23) JL = 23
      JH = JL+1
C
C SET UP THE CONSTANTS FOR THE INTERPOLATION OF THE BINGHAM PARAMETERS
C
      BI = TI-FLOAT(IL)
      AI = 1.-BI
C
      BJ = TJ-FLOAT(JL)
      AJ = 1.-BJ
C
C CHECK IF HARMONIC INTERPOLATION IS NEEDED
C
      IF (IK1(IL,JL).GT.3000) HARM1 = .TRUE.
      IF (IK2(IL,JL).GT.3000) HARM2 = .TRUE.
C
C WE INTERPOLATE ALONG TWO COLUMNS IN THE J DIRECTION, THEN ONCE
C  IN THE I DIRECTION BETWEEN THESE 2 VALUES.  THIS IS TO COMPENSATE
C  FOR THE CURVATURE IN THE K FUNCTIONS.
C
C INTERPOLATE FOR K1
C
      YLL = FLOAT(IK1(IL,JL))/TH
      YLH = FLOAT(IK1(IL,JH))/TH
      YHL = FLOAT(IK1(IH,JL))/TH
      YHH = FLOAT(IK1(IH,JH))/TH
      IF (HARM1) THEN
       YLL = 1./YLL
       YLH = 1./YLH
       YHL = 1./YHL
       YHH = 1./YHH
      ENDIF
      ZL = AJ*YLL + BJ*YLH
      ZH = AJ*YHL + BJ*YHH
      BK1 = AI*ZL + BI*ZH
      IF (HARM1) BK1 = 1./BK1
C
C INTERPOLATE FOR K2
C
      YLL = FLOAT(IK2(IL,JL))/TH
      YLH = FLOAT(IK2(IL,JH))/TH
      YHL = FLOAT(IK2(IH,JL))/TH
      YHH = FLOAT(IK2(IH,JH))/TH
      IF (HARM2) THEN
       YLL = 1./YLL
       YLH = 1./YLH
       YHL = 1./YHL
       YHH = 1./YHH
      ENDIF
      ZL = AJ*YLL + BJ*YLH
      ZH = AJ*YHL + BJ*YHH
      BK2 = AI*ZL + BI*ZH
      IF (HARM2) BK2 = 1./BK2
C
      GO TO 100
C
C IF EITHER T1 OR T2 ARE < .02, USE MARDIA'S APPROXIMATION FOR IT
C
50    CONTINUE
C
C IF EITHER T IS 0, MAKE THE CORRESPONDING K 1.E6 FOR A FLAG
C
      IF(T1.EQ.0.0) T1 = .0000005
      IF(T2.EQ.0.0) T2 = .0000005
C
      BK1 = -1./(2.*T1)
      BK2 = -1./(2.*T2)
C
100   RETURN
      END
      SUBROUTINE PLTLIN (AIN, AZ, CX, CY, PI, RAD, RMAX, MOVE)
C
      REAL              AIN                             ! ANGLE OF INCIDENCE OF SYMBOL
      REAL              AZ                              ! AZIMUTH OF SYMBOL
      REAL              CX                              ! X POSITION OF CIRCLE CENTER
      REAL              CY                              ! Y POSITION OF CIRCLE CENTER
      REAL              PI                              ! PI
      REAL              RAD                             ! PI/180
      REAL              RMAX                            ! RADIUS OF CIRCLE
      INTEGER           MOVE                            ! PEN INSTRUCTION

      REAL              AINR                            ! AIN IN RADIANS
      REAL              ANG                             ! PLOT ANGLE OF SYMBOL
      REAL              AZR                             ! AZ IN RADIANS
      REAL              CON                             ! RMAX * SQRT(2.0)
      REAL              R                               ! DISTANCE FROM CX, CY TO PLOT POSITION
      REAL              X                               ! X POSITION OF SYMBOL
      REAL              Y                               ! Y POSITION OF SYMBOL
C
      PARAMETER (ANG = 0.0)
C
      AZR = AZ*RAD
      AINR = AIN*RAD
C
C UPGOING RAYS
C
      IF (AIN .GT. 90.) THEN
        AINR = PI - AINR
        AZR = PI + AZR
      END IF
      CON = RMAX*SQRT(2.0)
      R = CON*SIN(AINR*0.5)
      X = R*SIN(AZR) + CX
      Y = R*COS(AZR) + CY
      CALL PLOT (X, Y, MOVE)
      RETURN
      END
      SUBROUTINE PLTBNG (CX, CY, HITE, PI, RAD, RMAX, SYMB, ALPHA1,
     & ALPHA2, VEC1, VEC2, VEC3, OUNIT)
C
C PLOTS PRINCIPAL AXIS, CONFIDENCE ELLIPSE
C
      REAL              ALPHA1                          ! CONFIDENCE ANGLE ABOUT VEC1-AXIS IN VEC2 DIRECTION
      REAL              ALPHA2                          ! CONFIDENCE ANGLE ABOUT VEC1-AXIS IN VEC3 DIRECTION
      REAL              CX                              ! X POSITION OF STEREO NET CENTER
      REAL              CY                              ! Y POSITION OF STEREO NET CENTER
      REAL              VEC1(3)                         ! EIGENVECTOR ABOUT WHICH ELLIPSE IS DRAWN
      REAL              VEC2(3)                         ! EIGENVECTOR NORMAL TO VEC1, VEC3
      REAL              VEC3(3)                         ! EIGENVECTOR NORMAL TO VEC1, VEC2
      REAL              HITE                            ! HEIGHT OF P,T SYMBOL IN LARGE CIRCLE
      INTEGER           OUNIT                           ! LOGICAL UNIT # OF OUTPUT FILE
      REAL              PI                              ! PI
      REAL              RAD                             ! PI/180
      REAL              RMAX                            ! RADIUS OF STEREO NET CIRCLE
      CHARACTER*1       SYMB                            ! AXIS #
C
      REAL              AIN                             ! ANGLE OF INCIDENCE
      REAL              DECL                            ! DECLINATION OF PRINCIPAL AXIS
      REAL              FINT                            ! INTENSITY (NOT USED)
      REAL              PLNG                            ! PLUNGLE OF PRINCIPAL AXIS
C
      CALL POLAR (VEC1(1), VEC1(2), VEC1(3), DECL, PLNG, FINT)
      WRITE (OUNIT, 10) SYMB, DECL, PLNG
10    FORMAT (1X, 'AXIS ', A1, ' DECLINATION, PLUNGE (DEG) = ', 3F10.2,
     & 5X, 2F10.2)
      CALL P2AIN (DECL, PLNG, AIN)
      CALL PLTSYP (AIN, DECL, CX, CY, HITE, '    ', PI, RAD, RMAX,
     & SYMB, 1.0)
      CALL CONF95 (ALPHA1, ALPHA2, VEC1, VEC2, VEC3, PI, RAD, CX, CY,
     & RMAX)
      RETURN
      END
c       subroutine polar
c
c       purpose
c           convert x,y,z components  back to dec,inc, and intensity
c
c       useage
c           call polar(x,y,z,dec,finc,fint)
c
c       description of parameters
c           x - real value of x component
c           y - real value of y component
c           z - real value of z component
c           dec - output declination of vector
c           finc - output inclination of vector
c           fint - intensity of output vector
c
c       subroutines and function subprograms required
c           none
c
      subroutine polar(xx,yy,zz,dec,finc,fint)
c     polar converts cartesian coordinates to polar coordinates
      data deg/57.29578/
       x = xx
       y = yy
       z = zz
      fint=sqrt(x*x+y*y+z*z)
       if(fint.eq.0.)  dec = 0.
       if(fint.eq.0.)  finc = 0.
       if(fint.eq.0.)  go to 10
      x=x/fint
      y=y/fint
      z=z/fint
      finc= asin(z)*deg
       if((x.eq.0.).and.(y.eq.0.)) dec = 0.
       if((x.eq.0.).and.(y.eq.0.))   go to 10
      dec=atan2(y,x)*deg
      if(dec) 5,10,10
5     dec=360.0+dec
10     continue
      return
      end
c       subroutine SUMPRD
c             j.l. kirschvink, princeton university, march, 1979
c
c       purpose
c          create the spherical matrix of the sums of squares and
c          products
c
c       useage
c          call sumprd(d,fi,n,fa)
c
c       description of parameters
c          d - array of declination values
c          fi - array of inclination values
c          n - number of samples in the array
c          fa - the six elements of the  matrix are returned in
c          this array (9), in the proper order for eigen.
c
c       subroutines and function subprograms required
c             none
c
       subroutine sumprd(d,fi,n,fa)
       dimension fa(9),d(n), fi(n)
       data ra/0.017453/
       do 230 k=1,6
230    fa(k) = 0.
       do 240 k = 1,n
       x = cos(ra*fi(k))*cos(ra*d(k))
       y = cos(ra*fi(k))*sin(ra*d(k))
       z = sin(ra*fi(k))
       fa(1) = fa(1) + x*x
       fa(2) = fa(2) + x*y
       fa(3) = fa(3) + y*y
       fa(4) = fa(4) + x*z
       fa(5) = fa(5) + y*z
240    fa(6) = fa(6) + z*z
       return
       end
      SUBROUTINE TRINGL (SIZE, X0, Y0)
C
C PLOT A TRIANGE
C
      REAL              SIZE                            ! SIZE OF TRIANGE
      REAL              X0                              ! X POSTION OF CENTER
      REAL              Y0                              ! Y POSTION OF CENTER
C
      REAL              SIZEX                           ! SCRATCH VARIABLE
      REAL              SIZEY                           ! SCRATCH VARIABLE
      REAL              X                               ! X PLOT POSTION
      REAL              Y                               ! Y PLOT POSTION
C
      PARAMETER (COS30 = 0.8660254, SIN30 = 0.5)
C
      SIZEY = SIZE*SIN30
      SIZEX =  SIZEY*COS30
C
C MOVE TO TOP
C
      Y = Y0 + SIZEY
      CALL PLOT (X0, Y, 3)
C
C DRAW TO LOWER LEFT
C
      X = X0 - SIZEX
      Y = Y0 - SIZEY/2
      CALL PLOT (X, Y, 2)
C
C DRAW TO LOWER RIGHT
C
      X = X0 + SIZEX
      CALL PLOT (X, Y, 2)
C
C DRAW TO TOP
C
      Y = Y0 + SIZEY
      CALL PLOT (X0, Y, 2)
C
      RETURN
      END
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine chcoord (a1, a2, a3, ap1, ap2, ap3, vec, vecp)

c     CHange COORDinates

c       Converts a vector expressed in terms of its components 
c     relative to coordinate system "a" in terms of its components
c     relative to coordinate system "ap".

c       a1,a2,a3 are unit axis vectors for coord system "a"
c     expressed in a "global" 1,2,3 coordinate system
c       ap1,ap2,ap3 are unit axis vectors for coord system "ap"
c     expressed in a "global" 1,2,3 coordinate system
c       vec contains the 3 components of a vector relative to "a"
c       vecp contains the 3 components of the same vector relative to "ap"
c       (vector contains the vector components in the "global" coordinate sys.)

c      Note that if user does not provide UNIT vectors for the axis directions
c     in "a" and "ap", they will be returned as unit vectors.

      real a1(3), a2(3), a3(3)
      real ap1(3), ap2(3), ap3(3)
      real vec(3), vecp(3), vector(3)

c     Force the axis vectors provided to be unit vectors.
      call unit (a1)
      call unit (a2)
      call unit (a3)
      call unit (ap1)
      call unit (ap2)
      call unit (ap3)

c     Convert the vector to the "global" coordinate system
      do 10 i=1,3
        vector(i) = vec(1)*a1(i) + vec(2)*a2(i) + vec(3)*a3(i)
 10   continue

      call dot (vector, ap1, vecp(1))
      call dot (vector, ap2, vecp(2))
      call dot (vector, ap3, vecp(3))

      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine unit(x)
c     Makes a unit vector out of x.

      real x(3)

      d = sqrt( x(1)**2 + x(2)**2 + x(3)**2 )

      if(d.ne.0.0) then
        do 20 i=1,3
 20     x(i) = x(i)/d
      endif

      return
      end


cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine dot(a,b,adotb)
c     Calculates the dot product of vectors a and b

      real a(3), b(3)

      adotb = 0.0

      do 10 i=1,3
 10   adotb = a(i)*b(i) + adotb

      return
      end


	SUBROUTINE P2AIN (AZ, PLNG, AIN)
	IF (PLNG .LT. 0.) THEN
	  PLNG = ABS(PLNG)
	  AZ = AZ + 180.
	ELSE IF (PLNG .GT. 90.) THEN
	  PRINT *, 'PLUNGE .GT. 90. IN P2AIN'
	  STOP
	END IF
	AIN = 90. - PLNG
	RETURN
	END
      SUBROUTINE CONF95 (A, B, V1, V2, V3, PI, RAD, CX, CY, RMAX)
C
C  COMPUTES AND PLOTS CONFIDENCE ELLIPSE ABOUT V1 IN DIRECTION V2, V3 FOR ANGLE A,B RESPECTIVELY
C
      REAL              A                               ! CONFIDENCE ANGLE (DEG) FROM V1 TO V2
      REAL              B                               ! CONFIDENCE ANGLE (DEG) FROM V1 TO V3
      REAL              CX                              ! X POSITION OF CENTER OF NET
      REAL              CY                              ! Y POSITION OF CENTER OF NET
      REAL              PI                              ! PI
      REAL              RAD                             ! PI/180.
      REAL              RMAX                            ! RADIUS OF STEREO NET CIRCLE
      REAL              V1(3)                           ! EIGENVECTOR ABOUT WHICH ELLIPSE IS DRAWN
      REAL              V2(3)                           ! EIGENVECTOR PERPENDICULAR TO V1, V3
      REAL              V3(3)                           ! EIGENVECTOR PERPENDICULAR TO V1, V2
C
      INTEGER           NPTS                           ! MAXIMUM # OF SOLUTIONS
      PARAMETER (NPTS = 181)
C
      REAL              AIN                             ! ANGLE OF INCIDENCE
      REAL              DECL                            ! DECLINATION
      REAL              DX                              ! X INCREMENT
      REAL              FINT                            ! INTENSITY (NOT USED)
      INTEGER           I                               ! LOOP INDEX
      INTEGER           MOVE                            ! PEN LIFT 
      REAL              OLD                             ! SIGN OF PREVIOUS PLUNGE
      REAL              OVEC(3)                         ! VEC ROTATED INTO X,Y,Z
      REAL              PHI                             ! ANGLE BETWEEN Z-AXIS AND POINT ON ELLIPSE
      REAL              PLNG                            ! PLUNGE
      REAL              SINA                            ! VERTIX ON X AXIS OF ELLIPSE
      REAL              SINB                            ! VERTIX ON Y AXIS OF ELLIPSE
      REAL              SINPHI                          ! SIN(PHI)
      REAL              SINSQA                          ! SINA*SINA
      REAL              SINSQB                          ! SINB*SINB
      REAL              THETA                           ! ANGLE BETWEEN X AXIS AND POINT ON ELLIPSE
      REAL              VEC(3)                          ! PROJECTION OF POINT ON ELLIPSE ONTO SPHERE IN V1-COORDINATE SYSTEM
      REAL              VEC1SAV(NPTS)                   ! DIRECTION COSINE OF 2ND HALF OF ELLIPSE 
      REAL              VEC2SAV(NPTS)                   ! DIRECTION COSINE OF 2ND HALF OF ELLIPSE 
      REAL              VEC3SAV(NPTS)                   ! DIRECTION COSINE OF 2ND HALF OF ELLIPSE 
      REAL              VI(3)                           ! UNIT VECTOR IN X DIRECTION
      REAL              VJ(3)                           ! UNIT VECTOR IN Y DIRECTION
      REAL              VK(3)                           ! UNIT VECTOR IN Z DIRECTION
      REAL              X                               ! X POSITION OF POINT ON ELLIPSE
      REAL              Y                               ! Y POSITION OF POINT ON ELLIPSE
      REAL              YSQ                             ! Y*Y
      REAL              Z                               ! Z POSITION OF POINT ON ELLIPSE
C
      SAVE VI, VJ, VK
C
      DATA VI/1., 0., 0./
      DATA VJ/0., 1., 0./
      DATA VK/0., 0., 1./
C
C FIND LARGEST VERTIX OF ELLIPSE.  RADIUS TO THIS POINT IS ONE AND ESTABLISHES VALUE OF Z AND VERTICES FOR ELLIPTIC CONE.
C
      IF (A .GT. B) THEN
        Z = COS(A*RAD)
        SINA = SIN(A*RAD)
        SINB = Z*SIN(B*RAD)
      ELSE
        Z = COS(B*RAD)
        SINA = Z*SIN(A*RAD)
        SINB = SIN(B*RAD)
      END IF
      SINSQA = SINA*SINA
      SINSQB = SINB*SINB
C
C  SET MINIMUM X VALUE, X INCREMENT AND SOLVE FOR Y ON ELLIPSE.  ONLY COMPUTE HALF ELLIPSE
C
      X = -SINA 
      DX = 2.*SINA/FLOAT(NPTS - 1)
      DO 10 I = 1, NPTS
        YSQ = SINSQB*(1. - X*X/SINSQA)
        IF (YSQ .LT. 0.) YSQ = 0.
        Y = SQRT(YSQ)
C
C  SOLVE FOR PHI, THETA AND PROJECT POINT UP TO SPHERE OF UNIT RADIUS 
C
        THETA = ATAN2(Y, X)
        PHI = ATAN2(SQRT(X*X + YSQ), Z)
        SINPHI = SIN(PHI)
        VEC(2) = SINPHI*COS(THETA)
        VEC(3) = SINPHI*SIN(THETA)
        VEC(1) = ABS(COS(PHI))
C
C  SAVE POINTS FOR SECOND HALF
C
        VEC1SAV(I) = VEC(1)
        VEC2SAV(I) = VEC(2)
        VEC3SAV(I) = -VEC(3)
C
C ROTATE COORDINATES INTO X,Y,Z SYSTEM
C
        CALL CHCOORD (V1, V2, V3, VI, VJ, VK, VEC, OVEC)
C
C FIND DECLINATION, PLUNGE
C
        CALL POLAR (OVEC(1), OVEC(2), OVEC(3), DECL, PLNG, FINT)
C
C IF PLUNGE FLIPS SIGN, LIFT PEN
C
        IF (I .EQ. 1) THEN
          MOVE = 3
        ELSE
          IF (SIGN(1., PLNG) .NE. OLD) THEN
            MOVE = 3
          ELSE
            MOVE = 2
          END IF
        END IF
        OLD = SIGN(1., PLNG)
C
C CONVERT TO ANGLE OF INCIDENCE AND PLOT POINT
C
        CALL P2AIN (DECL, PLNG, AIN)
        CALL PLTLIN (AIN, DECL, CX, CY, PI, RAD, RMAX, MOVE)
        X = X + DX
10      CONTINUE
C
C PLOT SECOND HALF OF ELLIPSE AS DESCRIBED ABOVE
C
      DO 20 I = 1, NPTS
        VEC(1) = VEC1SAV(I) 
        VEC(2) = VEC2SAV(I) 
        VEC(3) = VEC3SAV(I) 
        CALL CHCOORD (V1, V2, V3, VI, VJ, VK, VEC, OVEC)
        CALL POLAR (OVEC(1), OVEC(2), OVEC(3), DECL, PLNG, FINT)
        IF (I .EQ. 1) THEN
          MOVE = 3
        ELSE
          IF (SIGN(1., PLNG) .NE. OLD) THEN
            MOVE = 3
          ELSE
            MOVE = 2
          END IF
        END IF
        OLD = SIGN(1., PLNG)
        CALL P2AIN (DECL, PLNG, AIN)
        CALL PLTLIN (AIN, DECL, CX, CY, PI, RAD, RMAX, MOVE)
20    CONTINUE
      RETURN
      END
